<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>BBS per Verifier Linkability</title>
<meta content="Vasilis Kalos" name="author">
<meta content="Greg Bernstein" name="author">
<meta content="
       The BBS Signatures scheme defined in  , describes a multi-message digital signature, that supports selectively disclosing the messages through unlinkable presentations, built using zero-knowledge proofs. Each BBS proof reveals no information other than the signed messages that the Prover chooses to disclose in that specific instance. As such, the Verifier (i.e., the recipient) of the BBS proof, may not be able to track those presentations over time. Although in many applications this is desirable, there are use cases that require the Verifier be able to track the BBS proofs they receive from the same Prover. Examples include monitoring the use of access credentials for abnormal activity, monetization etc.. This document presents the use of pseudonyms with BBS proofs. 
       A pseudonym, is a value that will remain constant each time a Prover presents a BBS proof to the same Verifier, but will be different (and unlinkable), when the Prover interacts with a different Verifier. This provides a way for a recipient (Verifier) to track the presentations intended for them, while also hindering them from tracking the Prover's interactions with other Verifiers. 
    " name="description">
<meta content="xml2rfc 3.23.2" name="generator">
<meta content="draft-vasilis-bbs-per-verifier-linkability-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.23.2
    Python 3.12.7
    ConfigArgParse 1.7
    google-i18n-address 3.1.1
    intervaltree 3.1.0
    Jinja2 3.1.4
    lxml 4.9.4
    platformdirs 4.3.6
    pycountry 22.3.5
    PyYAML 6.0.1
    requests 2.32.3
    setuptools 70.3.0
    wcwidth 0.2.13
-->
<link href="draft-vasilis-bbs-per-verifier-linkability.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}

@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Lora SemiBold'), local('Lora-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Cabin Condensed';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Cabin Condensed SemiBold'), local('CabinCondensed-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/cabincondensed-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  color-scheme: light dark;
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --pilcrow-weak: #ddd;
  --pilcrow-strong: #bbb;
  --small-font-size: 14.5px;
  --font-mono: 'Oxygen Mono', monospace;
  scrollbar-color: #bbb #eee;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cabin Condensed", sans-serif;
  font-weight: 600;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
h1#title {
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1#title, h1#rfcnum {
  margin: 1.5em 0 0.2em;
}
h1#rfcnum + h1#title {
  margin: 0.2em 0;
}

h1, h2, h3 {
  font-size: 22px;
  line-height: 27px;
}
h4, h5, h6 {
  font-size: 20px;
  line-height: 24px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
}
#abstract+p {
  font-size: 18px;
  line-height: 24px;
}
#abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 16px;
  line-height: 0;
}

p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
/* font-family isn't space-separated, but =~ will have to do */
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
}
:is(ol, ul) :is(ol, ul) {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
:is(ul, ol).compact, .ulCompact, .olCompact {
  line-height: 1;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
  clear: left;
  --indent: 3ch;
  /* --indent: attr(indent ch); not supported in any browser, but we can dream */
}
dl.olPercent {
  --indent: 5ch;
}
dl > dt {
  float: left;
  margin-right: 2ch;
  min-width: 8ch;
}
dl.dlNewline > dt {
  float: none;
}
dl > dd {
  margin-bottom: .8em;
  margin-left: var(--indent) !important; /* stupid element overrides */
  min-height: 2ex;
}
dl.olPercent > dt {
  min-width: calc(var(--indent) - 2ch);
}
:is(dl.compact, .dlCompact) > dd {
  margin-bottom: 0;
}
:is(dl.compact, .dlCompact) > dd > :is(:first-child, .break:first-child + *) {
  margin-top: 0;
}
:is(dl.compact, .dlCompact) > dd > :is(:last-child) {
  margin-bottom: 0;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0;
}
:is(dd, span).break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href] {
  color: var(--link-color);
}
a[href].selfRef, .iref + a[href].internal {
  color: var(--text-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref:is(.cite, .auto), :is(#status-of-memo, #copyright) a {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px var(--font-mono);
}
tt, code {
  /* changing the font for inline elements leads to different ascender
     and descender heights; as we want to retain baseline alignment,
     remove leading to avoid altering the final height of lines
     note: this fails if these blocks take an entire line,
     a different solution would be great */
  line-height: 0;
}
:is(h1, h2, h3, h4, h5, h6) :is(tt, code) {
  font-size: 84%;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
  padding: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
}
@media screen {
  /* Auto-collapse boilerplate. */
  :is(#status-of-memo, #copyright) p {
    margin: -2px 0;
    max-height: 0;
    transition: max-height 2s ease, margin 0.5s ease 0.5s;
    overflow: hidden;
  }
  :is(#status-of-memo, #copyright):hover p,
  :is(#status-of-memo, #copyright) h2:target ~ p {
    margin: 0.5em 0;
    max-height: 500px;
    overflow: auto;
  }
  pre, svg {
    display: inline-block;
    overflow-x: auto;
  }
  pre {
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  svg {
    max-width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  :is(pre, svg) + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
:is(tr:nth-child(2n), thead+tbody > tr:nth-child(2n+1)) > td {
  background-color: var(--background-color);
}
:is(tr:nth-child(2n+1), thead+tbody > tr:nth-child(2n)) > td {
  background-color: var(--highlight-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  opacity: 0.2;
  user-select: none;
}
a.pilcrow[href] { color: var(--pilcrow-weak); }
a.pilcrow[href]:hover { text-decoration: none; }
@media not print {
  :hover > a.pilcrow {
    opacity: 1;
  }
  a.pilcrow[href]:hover {
    color: var(--pilcrow-strong);
    background-color: transparent;
  }
}
@media print {
  a.pilcrow {
    display: none;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
  font-weight: 600;
  font-size: var(--small-font-size);
}
.role {
  font-variant: all-small-caps;
}
sub, sup {
  line-height: 1;
  font-size: 80%;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 15ch;
}
#identifiers dt {
  width: var(--identifier-width);
  min-width: var(--identifier-width);
  clear: left;
  float: left;
  text-align: right;
  margin-right: 1ch;
}
#identifiers dd {
  margin: 0;
  margin-left: calc(1em + var(--identifier-width)) !important;
  min-width: 5em;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
#toc nav ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
#toc nav li {
  line-height: 1.3em;
  margin: 2px 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
#toc a.xref {
  white-space: normal;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 10ch;
  margin-right: 1.5ch;
}
.references dt:target::before {
  content: "⇒";
  width: 15px;
  margin: 0 10px 0 -25px;
}
.references dd {
  margin-left: 12ch !important;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
#rfc\.index\.index + ul {
  margin-left: 0;
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}
address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 1px 0 0 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc.active {
      opacity: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 8px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active nav {
    display: block;
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin-top: 2px;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  #toc nav > ul  {
    margin-bottom: 2em;
  }
  #toc ul {
    margin: 0 0 0 4px;
    font-size: var(--small-font-size);
  }
  #toc ul :is(p, li) {
    margin: 2px 0;
    line-height: 22px;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre, .vcard {
    page-break-inside: avoid;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  :is(h2, h3, h4, h5, h6)+*, dd {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
  .toplink {
    display: none;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Changes introduced to fix issues found during implementation */

/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}

/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin: 8px 0.5em 0;
}

/* Provide styling for table cell text alignment */
table .text-left {
  text-align: left;
}
table .text-center {
  text-align: center;
}
table .text-right {
  text-align: right;
}

/* Make the alternative author contact information look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 20em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Dark mode. */
@media (prefers-color-scheme: dark) {
:root {
  --background-color: #121212;
  --text-color: #f0f0f0;
  --title-color: #fff;
  --link-color: #4da4f0;
  --highlight-color: #282828;
  --line-color: #444;
  --pilcrow-weak: #444;
  --pilcrow-strong: #666;
  scrollbar-color: #777 #333;
}
}

/* SVG Trick: a prefix match works because only black and white are allowed */
svg :is([stroke="black"], [stroke^="#000"]) {
  stroke: var(--text-color);
}
svg :is([stroke="white"], [stroke^="#fff"]) {
  stroke: var(--background-color);
}
svg :is([fill="black"], [fill^="#000"], :not([fill])) {
  fill: var(--text-color);
}
svg :is([fill="white"], [fill^="#fff"]) {
  fill: var(--background-color);
}
</style>

</head>
<body class="xml2rfc">
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">BBS per Verifier Linkability</td>
<td class="right">October 2024</td>
</tr></thead>
<tfoot><tr>
<td class="left">Kalos &amp; Bernstein</td>
<td class="center">Expires 13 April 2025</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">none</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-vasilis-bbs-per-verifier-linkability-latest</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2024-10-10" class="published">10 October 2024</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Informational</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2025-04-13">13 April 2025</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">V. Kalos</div>
<div class="org">MATTR</div>
</div>
<div class="author">
      <div class="author-name">G. Bernstein</div>
<div class="org">Grotto Networking</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">BBS per Verifier Linkability</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">The BBS Signatures scheme defined in <span>[<a href="#I-D.irtf-cfrg-bbs-signatures" class="cite xref">I-D.irtf-cfrg-bbs-signatures</a>]</span>, describes a multi-message digital signature, that supports selectively disclosing the messages through unlinkable presentations, built using zero-knowledge proofs. Each BBS proof reveals no information other than the signed messages that the Prover chooses to disclose in that specific instance. As such, the Verifier (i.e., the recipient) of the BBS proof, may not be able to track those presentations over time. Although in many applications this is desirable, there are use cases that require the Verifier be able to track the BBS proofs they receive from the same Prover. Examples include monitoring the use of access credentials for abnormal activity, monetization etc.. This document presents the use of pseudonyms with BBS proofs.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
<p id="section-abstract-2">A pseudonym, is a value that will remain constant each time a Prover presents a BBS proof to the same Verifier, but will be different (and unlinkable), when the Prover interacts with a different Verifier. This provides a way for a recipient (Verifier) to track the presentations intended for them, while also hindering them from tracking the Prover's interactions with other Verifiers.<a href="#section-abstract-2" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 13 April 2025.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1" class="keepWithNext"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-terminology" class="internal xref">Terminology</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="auto internal xref">1.2</a>.  <a href="#name-notation" class="internal xref">Notation</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-conventions-and-definitions" class="internal xref">Conventions and Definitions</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-key-concepts" class="internal xref">Key Concepts</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="auto internal xref">3.1</a>.  <a href="#name-prover-identifier" class="internal xref">Prover Identifier</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="auto internal xref">3.2</a>.  <a href="#name-verifier-identifier" class="internal xref">Verifier Identifier</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="auto internal xref">3.3</a>.  <a href="#name-pseudonyms" class="internal xref">Pseudonyms</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.4">
                <p id="section-toc.1-1.3.2.4.1"><a href="#section-3.4" class="auto internal xref">3.4</a>.  <a href="#name-mapping-messages-to-scalars" class="internal xref">Mapping Messages to Scalars</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-pseudonym-calculation-proce" class="internal xref">Pseudonym Calculation Procedure</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-high-level-procedures-and-i" class="internal xref">High Level Procedures and Information Flows</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-bbs-pseudonym-interface" class="internal xref">BBS Pseudonym Interface</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="auto internal xref">6.1</a>.  <a href="#name-signature-generation-and-ve" class="internal xref">Signature Generation and Verification with Pseudonym</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.1">
                    <p id="section-toc.1-1.6.2.1.2.1.1"><a href="#section-6.1.1" class="auto internal xref">6.1.1</a>.  <a href="#name-commitment" class="internal xref">Commitment</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.2">
                    <p id="section-toc.1-1.6.2.1.2.2.1"><a href="#section-6.1.2" class="auto internal xref">6.1.2</a>.  <a href="#name-blind-issuance" class="internal xref">Blind Issuance</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.1.2.3">
                    <p id="section-toc.1-1.6.2.1.2.3.1"><a href="#section-6.1.3" class="auto internal xref">6.1.3</a>.  <a href="#name-verification-and-finalizati" class="internal xref">Verification and Finalization</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="auto internal xref">6.2</a>.  <a href="#name-proof-generation-with-pseud" class="internal xref">Proof Generation with Pseudonym</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="auto internal xref">6.3</a>.  <a href="#name-proof-verification-with-pse" class="internal xref">Proof Verification with Pseudonym</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-core-operations" class="internal xref">Core Operations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="auto internal xref">7.1</a>.  <a href="#name-core-proof-generation" class="internal xref">Core Proof Generation</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="auto internal xref">7.2</a>.  <a href="#name-core-proof-verification" class="internal xref">Core Proof Verification</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="auto internal xref">7.3</a>.  <a href="#name-pseudonym-proof-generation-" class="internal xref">Pseudonym Proof Generation Utilities</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.1">
                    <p id="section-toc.1-1.7.2.3.2.1.1"><a href="#section-7.3.1" class="auto internal xref">7.3.1</a>.  <a href="#name-pseudonym-proof-generation-i" class="internal xref">Pseudonym Proof Generation Initialization</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7.2.3.2.2">
                    <p id="section-toc.1-1.7.2.3.2.2.1"><a href="#section-7.3.2" class="auto internal xref">7.3.2</a>.  <a href="#name-pseudonym-proof-verificatio" class="internal xref">Pseudonym Proof Verification Initialization</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-utility-operations" class="internal xref">Utility Operations</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8.2.1">
                <p id="section-toc.1-1.8.2.1.1"><a href="#section-8.1" class="auto internal xref">8.1</a>.  <a href="#name-challenge-calculation" class="internal xref">Challenge Calculation</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-ciphersuites" class="internal xref">Ciphersuites</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="auto internal xref">11</a>. <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#section-12" class="auto internal xref">12</a>. <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.1">
                <p id="section-toc.1-1.12.2.1.1"><a href="#section-12.1" class="auto internal xref">12.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12.2.2">
                <p id="section-toc.1-1.12.2.2.1"><a href="#section-12.2" class="auto internal xref">12.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#appendix-A" class="auto internal xref">Appendix A</a>.  <a href="#name-acknowledgments" class="internal xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#appendix-B" class="auto internal xref">Appendix B</a>.  <a href="#name-detailed-blind-signature-ge" class="internal xref">Detailed Blind Signature Generation with Pseudonym</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#appendix-C" class="auto internal xref">Appendix C</a>.  <a href="#name-detailed-proof-generation-w" class="internal xref">Detailed Proof Generation with Pseudonym</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a href="#appendix-D" class="auto internal xref">Appendix D</a>.  <a href="#name-detailed-proof-verification" class="internal xref">Detailed Proof Verification with Pseudonym</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.17">
            <p id="section-toc.1-1.17.1"><a href="#appendix-E" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">The BBS Signature Scheme, originally described in the academic work by Dan Boneh, Xavier Boyen, and Hovav Shacham <span>[<a href="#BBS04" class="cite xref">BBS04</a>]</span>, is a signature scheme able to sign multiple messages at once, allowing for selectively disclosing those message while not revealing the signature it self. It does so by creating unlinkable, zero-knowledge proofs-of-knowledge of a signature value on (among other) the disclosed set of messages. More specifically, the BBS Prover, will create a BBS proof that if validated by the Verifier, guarantees that the prover knows a BBS signature on the disclosed messages, guaranteeing the revealed messages authenticity and integrity.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">The BBS Proof is by design unlinkable, meaning that given two different BBS proofs, there is no way to tell if they originated from the same BBS signature. This means that if a Prover does not reveal any other identifying information (for example if they are using proxies to hide their IP address etc.), the Verifier of the proof will not be able "track" or "correlate" the different proof presentations  or the Provers activity via cryptographic artifacts. This helps enhance user privacy in applications where the Verifier only needs to know that the Prover is in possession of a valid BBS signature over a list of disclosed messages.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">In some applications, however, the Verifier needs to track the presentations made by the Prover over time, as to provide security monitoring, monetization services, configuration persistance etc.. To promote privacy reason, the Prover should not reveal or be bound to a unique identifier that would remain constant across proof presentations to different Verifiers and which could be used to link a Provers interactions with different Verifiers.<a href="#section-1-3" class="pilcrow">¶</a></p>
<p id="section-1-4">The goal of this document is to provide a way for a Verifier to track the proof presentations that are intended for them, while at the same time not allowing the tracking of the Prover's activities with other Verifiers. This is done through the use of Pseudonyms. A pseudonym as defined by this document, is a value that will be constant when the Prover presents BBS proofs to the same Verifier, but will change when the Prover interacts with different recipients (with no way to link the two distinct pseudonym values together). This is done by constructing the pseudonym value by combining a unique Verifier identifier with a unique Prover identifier.<a href="#section-1-4" class="pilcrow">¶</a></p>
<p id="section-1-5">To avoid forging requests, the Prover's identifier will be signed by the same BBS signature used to generate the BBS proof. This requires extending the BBS proof generation and verification operations with some additional computations that will be used to prove correctness of the pseudonym, i.e., that it was correctly calculated using the Verifier identifier, as well as, the undisclosed and signed Prover identifier. The Prover identifier MUST be considered secret from the point of view of the Prover, since, if it is revealed, any entity will be able to track the Prover's activity across any Verifiers.<a href="#section-1-5" class="pilcrow">¶</a></p>
<p id="section-1-6">This document will define new BBS Interfaces for use with pseudonyms, however it will not define new ciphersuites. Rather it will re-use the ciphersuites defined in <a href="https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-03.html#name-ciphersuites">Section 6</a> of <span>[<a href="#I-D.irtf-cfrg-bbs-signatures" class="cite xref">I-D.irtf-cfrg-bbs-signatures</a>]</span>).<a href="#section-1-6" class="pilcrow">¶</a></p>
<p id="section-1-7">Pseudonyms when used appropriately prevent verifiers from linking prover (proof) presentations between them. We call this verifier-verifier collusion. In addition pseudonyms can be used to prevent the signer from linking prover presentations to a verifier. We call this verifier-signer collusion. This second property is not always desirable in all use cases, for example to allow tracking of purchases a controlled substance by a prover by a central authority while preventing tracking by individual shops.<a href="#section-1-7" class="pilcrow">¶</a></p>
<p id="section-1-8">This specification provides for pseudonyms that provide for both use cases above. We call the case that prevents linkage across verifiers and signer <em>psuedonyms with hidden pid</em> while the case that allows for signer linkage <em>pseudonyms with signer provided pid</em>.<a href="#section-1-8" class="pilcrow">¶</a></p>
<div id="terminology">
<section id="section-1.1">
        <h3 id="name-terminology">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-terminology" class="section-name selfRef">Terminology</a>
        </h3>
<p id="section-1.1-1">The following terminology is used throughout this document:<a href="#section-1.1-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlCompact dlParallel" id="section-1.1-2">
          <dt id="section-1.1-2.1">SK</dt>
          <dd style="margin-left: 1.5em" id="section-1.1-2.2">The secret key for the signature scheme.<a href="#section-1.1-2.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.1-2.3">PK</dt>
          <dd style="margin-left: 1.5em" id="section-1.1-2.4">The public key for the signature scheme.<a href="#section-1.1-2.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.1-2.5">L</dt>
          <dd style="margin-left: 1.5em" id="section-1.1-2.6">The total number of signed messages.<a href="#section-1.1-2.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.1-2.7">R</dt>
          <dd style="margin-left: 1.5em" id="section-1.1-2.8">The number of message indexes that are disclosed (revealed) in a proof-of-knowledge of a signature.<a href="#section-1.1-2.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.1-2.9">U</dt>
          <dd style="margin-left: 1.5em" id="section-1.1-2.10">The number of message indexes that are undisclosed in a proof-of-knowledge of a signature.<a href="#section-1.1-2.10" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.1-2.11">scalar</dt>
          <dd style="margin-left: 1.5em" id="section-1.1-2.12">An integer between 0 and r-1, where r is the prime order of the selected groups, defined by each ciphersuite (see also <a href="#notation">Notation</a>).<a href="#section-1.1-2.12" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.1-2.13">generator</dt>
          <dd style="margin-left: 1.5em" id="section-1.1-2.14">A valid point on the selected subgroup of the curve being used that is employed to commit a value.<a href="#section-1.1-2.14" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.1-2.15">signature</dt>
          <dd style="margin-left: 1.5em" id="section-1.1-2.16">The digital signature output.<a href="#section-1.1-2.16" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.1-2.17">presentation_header (ph)</dt>
          <dd style="margin-left: 1.5em" id="section-1.1-2.18">A payload generated and bound to the context of a specific spk.<a href="#section-1.1-2.18" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.1-2.19">INVALID, ABORT</dt>
          <dd style="margin-left: 1.5em" id="section-1.1-2.20">Error indicators. INVALID refers to an error encountered during the Deserialization or Procedure steps of an operation. An INVALID value can be returned by a subroutine and handled by the calling operation. ABORT indicates that one or more of the initial constraints defined by the operation are not met. In that case, the operation will stop execution. An operation calling a subroutine that aborted must also immediately abort.<a href="#section-1.1-2.20" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
<div id="notation">
<section id="section-1.2">
        <h3 id="name-notation">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-notation" class="section-name selfRef">Notation</a>
        </h3>
<p id="section-1.2-1">The following notation and primitives are used:<a href="#section-1.2-1" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlCompact dlParallel" id="section-1.2-2">
          <dt id="section-1.2-2.1">a || b</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-2.2">Denotes the concatenation of octet strings a and b.<a href="#section-1.2-2.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.3">I \ J</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-2.4">For sets I and J, denotes the difference of the two sets i.e., all the elements of I that do not appear in J, in the same order as they were in I.<a href="#section-1.2-2.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.5">X[a..b]</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-2.6">Denotes a slice of the array <code>X</code> containing all elements from and including the value at index <code>a</code> until and including the value at index <code>b</code>. Note when this syntax is applied to an octet string, each element in the array <code>X</code> is assumed to be a single byte.<a href="#section-1.2-2.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.7">range(a, b)</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-2.8">For integers a and b, with a &lt;= b, denotes the ascending ordered list of all integers between a and b inclusive (i.e., the integers "i" such that a &lt;= i &lt;= b).<a href="#section-1.2-2.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-2.9">length(input)</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-2.10">Takes as input either an array or an octet string. If the input is an array, returns the number of elements of the array. If the input is an octet string, returns the number of bytes of the inputted octet string.<a href="#section-1.2-2.10" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
<p id="section-1.2-3">Terms specific to pairing-friendly elliptic curves that are relevant to this document are restated below, originally defined in <span>[<a href="#I-D.irtf-cfrg-pairing-friendly-curves" class="cite xref">I-D.irtf-cfrg-pairing-friendly-curves</a>]</span>.<a href="#section-1.2-3" class="pilcrow">¶</a></p>
<span class="break"></span><dl class="dlCompact dlParallel" id="section-1.2-4">
          <dt id="section-1.2-4.1">E1, E2</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-4.2">elliptic curve groups defined over finite fields. This document assumes that E1 has a more compact representation than E2, i.e., because E1 is defined over a smaller field than E2. For a pairing-friendly curve, this document denotes operations in E1 and E2 in additive notation, i.e., P + Q denotes point addition and x * P denotes scalar multiplication.<a href="#section-1.2-4.2" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-4.3">G1, G2</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-4.4">subgroups of E1 and E2 (respectively) having prime order r.<a href="#section-1.2-4.4" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-4.5">GT</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-4.6">a subgroup, of prime order r, of the multiplicative group of a field extension.<a href="#section-1.2-4.6" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-4.7">e</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-4.8">G1 x G2 -&gt; GT: a non-degenerate bilinear map.<a href="#section-1.2-4.8" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-4.9">r</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-4.10">The prime order of the G1 and G2 subgroups.<a href="#section-1.2-4.10" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-4.11">BP1, BP2</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-4.12">base (constant) points on the G1 and G2 subgroups respectively.<a href="#section-1.2-4.12" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-4.13">Identity_G1, Identity_G2, Identity_GT</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-4.14">The identity element for the G1, G2, and GT subgroups respectively.<a href="#section-1.2-4.14" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-4.15">hash_to_curve_g1(ostr, dst) -&gt; P</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-4.16">A cryptographic hash function that takes an arbitrary octet string as input and returns a point in G1, using the hash_to_curve operation defined in <span>[<a href="#I-D.irtf-cfrg-hash-to-curve" class="cite xref">I-D.irtf-cfrg-hash-to-curve</a>]</span> and the inputted dst as the domain separation tag for that operation (more specifically, the inputted dst will become the DST parameter for the hash_to_field operation, called by hash_to_curve).<a href="#section-1.2-4.16" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-4.17">point_to_octets_g1(P) -&gt; ostr, point_to_octets_g2(P) -&gt; ostr</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-4.18">returns the canonical representation of the point P for the respective subgroup as an octet string. This operation is also known as serialization.<a href="#section-1.2-4.18" class="pilcrow">¶</a>
</dd>
          <dd class="break"></dd>
<dt id="section-1.2-4.19">octets_to_point_g1(ostr) -&gt; P, octets_to_point_g2(ostr) -&gt; P</dt>
          <dd style="margin-left: 1.5em" id="section-1.2-4.20">returns the point P for the respective subgroup corresponding to the canonical representation ostr, or INVALID if ostr is not a valid output of the respective point_to_octets_g* function. This operation is also known as deserialization.<a href="#section-1.2-4.20" class="pilcrow">¶</a>
</dd>
        <dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="conventions-and-definitions">
<section id="section-2">
      <h2 id="name-conventions-and-definitions">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-conventions-and-definitions" class="section-name selfRef">Conventions and Definitions</a>
      </h2>
<p id="section-2-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span> when, and only when, they appear in all capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="key-concepts">
<section id="section-3">
      <h2 id="name-key-concepts">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-key-concepts" class="section-name selfRef">Key Concepts</a>
      </h2>
<p id="section-3-1">A <em>pseudonym</em> will be cryptographically generated for each prover-verifier pair. Its value is dependent on a <em>prover identifier</em> (<em>pid</em>) and a verifier identifier (<em>verifier_id</em>).<a href="#section-3-1" class="pilcrow">¶</a></p>
<div id="prover-identifier">
<section id="section-3.1">
        <h3 id="name-prover-identifier">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-prover-identifier" class="section-name selfRef">Prover Identifier</a>
      </h3>
</section>
</div>
<div id="verifier-identifier">
<section id="section-3.2">
        <h3 id="name-verifier-identifier">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-verifier-identifier" class="section-name selfRef">Verifier Identifier</a>
        </h3>
<p id="section-3.2-1">The Verifier Identifier (<em>verifier_id</em>) is an octet string that SHOULD be unique to a verifier and is generated by a verifier. Unlike a <em>pid</em> this value does not need to be kept secret from other entities. In fact, this value must be known to all provers that will be presenting proofs to the verifier. The mechanism for conveying the <em>verifier_id</em> to the prover is application specific and not specified here.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
<p id="section-3.2-2">In addition, as we will see in the computation of a pseudonym, this value gets hashed into the group G1, and hence doesn't have the same randomness requirements as a <em>pid</em>. Hence, well known, unique verifier associated information such as a domain name could be used as the basis of a verifier id, but this specification does not dictate any particular format.<a href="#section-3.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="pseudonyms">
<section id="section-3.3">
        <h3 id="name-pseudonyms">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-pseudonyms" class="section-name selfRef">Pseudonyms</a>
        </h3>
<p id="section-3.3-1">The <em>pseudonym</em> is a cryptographic value computed by the prover based on the <em>pid</em> and the <em>verifier_id</em>. At a high level this is computed by hashing the <em>verifier_id</em> to the elliptic curve group G1 and then exponentiating by the <em>pid</em> value. See Section <a href="#pseudonym-calculation-procedure" class="auto internal xref">Section 4</a> for details. The <em>pseudonym</em> is sent to a verifier along with the proof.<a href="#section-3.3-1" class="pilcrow">¶</a></p>
<p id="section-3.3-2">This document defines a pseudonym as point of the G1 group different from the Identity (<code>Identity_G1</code>) or the base point (<code>BP1</code>) of G1. A pseudonym remains constant for each Prover and Verifier pair, but is unique (and unlinkable) across different Provers or Verifiers. In other words, when the Prover presents multiple BBS proofs with a pseudonym to a Verifier, the pseudonym value will be constant across those presentations. When presenting a BBS proof with a pseudonym to another Verifier however, the pseudonym value will be different. Note that since pseudonyms are group points, their value will necessarily change if a different a ciphersuite with a different curve will be used. Serialization and deserialization of the pseudonym point MUST be done using the <code>point_to_octets_g1</code> and <code>octets_to_point_g1</code> defined by the BBS ciphersuite used (see <a href="https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-03.html#name-ciphersuites">Section 6</a> of <span>[<a href="#I-D.irtf-cfrg-bbs-signatures" class="cite xref">I-D.irtf-cfrg-bbs-signatures</a>]</span>).<a href="#section-3.3-2" class="pilcrow">¶</a></p>
<p id="section-3.3-3">This document specifies pseudonyms to be BBS Interface specific (see Section TBD of <span>[<a href="#I-D.irtf-cfrg-bbs-signatures" class="cite xref">I-D.irtf-cfrg-bbs-signatures</a>]</span> for the definition of the BBS Interface). It is outside the scope of this document to provide a procedure for "linking" the pseudonyms that are used by different Interfaces or that are based on different ciphersuites. An option is for the Prover to present both Pseudonyms with the relevant BBS proofs to the Verifier, and upon validation of both, the Verifier to internally link the 2 pseudonyms together.<a href="#section-3.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="mapping-messages-to-scalars">
<section id="section-3.4">
        <h3 id="name-mapping-messages-to-scalars">
<a href="#section-3.4" class="section-number selfRef">3.4. </a><a href="#name-mapping-messages-to-scalars" class="section-name selfRef">Mapping Messages to Scalars</a>
        </h3>
<p id="section-3.4-1">Each BBS Interface defines an operation that will map the inputted messages to scalar values, required by the core BBS operations. Each Interface can use a different mapping procedure, as long as it comforts to the requirements outlined in <span>[<a href="#I-D.irtf-cfrg-bbs-signatures" class="cite xref">I-D.irtf-cfrg-bbs-signatures</a>]</span>. For using BBS with pseudonyms, the mapping operation used by the interface is REQUIRED to additionally adhere the following rule;<a href="#section-3.4-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-3.4-2">
<pre>For each set of messages and separate message msg',
if C1 = messages_to_scalars(messages.push(msg')),
and msg_prime_scalar = messages_to_scalars((msg')),
and C2 = messages_to_scalars(messages).push(msg_prime_scalar),
it will always hold that C1 == C2.

</pre><a href="#section-3.4-2" class="pilcrow">¶</a>
</div>
<p id="section-3.4-3">Informally, the above means that each message is mapped to a scalar independently from all the other messages. For example, if <code>a = messages_to_scalars((msg_1))</code> and <code>b = messages_to_scalars((msg_2))</code>, then <code>(a, b) = messages_to_scalars((msg_1, msg_2))</code>. Its trivial to see that the <code>messages_to_scalars</code> operation that is defined in Section TBD of <span>[<a href="#I-D.irtf-cfrg-bbs-signatures" class="cite xref">I-D.irtf-cfrg-bbs-signatures</a>]</span>, has the required property. That operation will be used by the Interface defined in this document to map the messages to scalars. Note that the above operation (and hence the defined by this document Interface), only accepts messages that are octet strings.<a href="#section-3.4-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="pseudonym-calculation-procedure">
<section id="section-4">
      <h2 id="name-pseudonym-calculation-proce">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-pseudonym-calculation-proce" class="section-name selfRef">Pseudonym Calculation Procedure</a>
      </h2>
<p id="section-4-1">The following section describes how to calculate a pseudonym from a secret held by the Prover and the public context unique identifier. The pseudonym will be unique for different contexts (e.g., unique Verifier identifiers) and constant under constant inputs (i.e., the same <code>context_id</code> and <code>nym_secret</code>). The <code>context_id</code> is an octet string representing the unique identifier of the context in which the Pseudonym will have the same value. The <code>nym_secret</code> value is a scalar calculated from secret input provided by the Prover and random (but not secret) input provided by the Signer. This will guarantee uniqueness of the <code>nym_secret</code> between different signatures and users.<a href="#section-4-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4-2">
<pre>Pseudonym = hash_to_curve_g1(context_id) * nym_secret

</pre><a href="#section-4-2" class="pilcrow">¶</a>
</div>
<p id="section-4-3">Additionally, the <code>nym_secret</code> value will be signed by the BBS Signature. This will bind the Pseudonym to a specific signature, held by the Prover. During proof generation, along the normal BBS proof, the Prover will generate a proof of correctness of the Pseudonym, i.e., that it has the form described above, and that it was constructed using a <code>nym_secret</code> signed by the BBS signature used to generate that proof.<a href="#section-4-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="high-level-procedures-and-information-flows">
<section id="section-5">
      <h2 id="name-high-level-procedures-and-i">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-high-level-procedures-and-i" class="section-name selfRef">High Level Procedures and Information Flows</a>
      </h2>
<p id="section-5-1">To prevent forgeries in all cases all BBS messages are signed with the inclusion of some form of the provider identifier (<em>pid</em>). In addition the pseudonym is always computed by the prover and sent with the proof to the verifier. While two different variations of signature and proof generation are given below based on the previously discussed unlinkability requirements there MUST be only one verification algorithm for the verifier to use.<a href="#section-5-1" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="compact type-1" id="section-5-2">
<li id="section-5-2.1">The Prover computes their input for the <code>nym_secret</code> (called <code>prover_nym</code>) and retained for use when calculating the <code>nym_secret</code> value.<a href="#section-5-2.1" class="pilcrow">¶</a>
</li>
        <li id="section-5-2.2">The Prover will wrap up in a cryptographic commitment using the <em>Commit</em> procedures of Blind BBS the messages they want to include in the signature (<code>committed_messages</code>) and the <code>prover_nym</code> value, generating a <code>commitment_with_proof</code> and a <code>secret_prover_blind</code>.<a href="#section-5-2.2" class="pilcrow">¶</a>
</li>
        <li id="section-5-2.3">The <code>commitment_with_proof</code> is conveyed to the signer which then uses the signing procedures in Section <a href="#signature-generation-and-verification-with-pseudonym" class="auto internal xref">Section 6.1</a> to create a BBS signature and their input for the <code>nym_secret</code> value, called <code>signer_nym_entropy</code>. They will convey both to the Prover.<a href="#section-5-2.3" class="pilcrow">¶</a>
</li>
        <li id="section-5-2.4">On receipt of the signature and the <code>signer_nym_entropy</code> value, the Prover verifies the signature using the procedure of section <a href="#signature-generation-and-verification-with-pseudonym" class="auto internal xref">Section 6.1</a> and calculates the <code>nym_secret</code> value by adding their <code>prover_nym</code> secret and the provided <code>signer_nym_entropy</code> values.<a href="#section-5-2.4" class="pilcrow">¶</a>
</li>
        <li id="section-5-2.5">The Prover computes the <em>pseudonym</em> based on the <code>nym_secret</code> and the pseudonym's context identifier <code>context_id</code>.<a href="#section-5-2.5" class="pilcrow">¶</a>
</li>
        <li id="section-5-2.6">The Prover generates a proof using <code>nym_secret</code>, <code>secret_prover_blind</code>, <code>signature</code>, <code>messages</code>, <code>committed_messages</code> and the indexes of the messages to be reveled from those two lists (i.e., <code>disclosed_indexes</code> and <code>disclosed_committed_indexes</code>)  using the procedures of Section <a href="#proof-generation-with-pseudonym" class="auto internal xref">Section 6.2</a>.<a href="#section-5-2.6" class="pilcrow">¶</a>
</li>
        <li id="section-5-2.7">The Prover conveys the <code>proof</code> and <code>Pseudonym</code> to the verifier. The verifier uses the procedure of Section <a href="#proof-verification-with-pseudonym" class="auto internal xref">Section 6.3</a> to verify the proof.<a href="#section-5-2.7" class="pilcrow">¶</a>
</li>
      </ol>
</section>
</div>
<div id="bbs-pseudonym-interface">
<section id="section-6">
      <h2 id="name-bbs-pseudonym-interface">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-bbs-pseudonym-interface" class="section-name selfRef">BBS Pseudonym Interface</a>
      </h2>
<p id="section-6-1">The following section defines a BBS Interface that will make use of per-origin pseudonyms where the <em>pid</em> value is only known to the prover. The identifier of the Interface, api_id,  is defined as <code>ciphersuite_id || H2G_HM2S_PSEUDONYM_</code>, where <code>ciphersuite_id</code> the unique identifier of the BBS ciphersuite used, as is defined in <a href="https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-03.html#name-ciphersuites">Section 6</a> of <span>[<a href="#I-D.irtf-cfrg-bbs-signatures" class="cite xref">I-D.irtf-cfrg-bbs-signatures</a>]</span>).<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">In this case the prover create a pid value and keeps it secret. Only sending a commitment with the proof of the pid that the signer will used when creating the signature.<a href="#section-6-2" class="pilcrow">¶</a></p>
<div id="signature-generation-and-verification-with-pseudonym">
<section id="section-6.1">
        <h3 id="name-signature-generation-and-ve">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-signature-generation-and-ve" class="section-name selfRef">Signature Generation and Verification with Pseudonym</a>
        </h3>
<div id="commitment">
<section id="section-6.1.1">
          <h4 id="name-commitment">
<a href="#section-6.1.1" class="section-number selfRef">6.1.1. </a><a href="#name-commitment" class="section-name selfRef">Commitment</a>
          </h4>
<p id="section-6.1.1-1">This section will describe the steps with which the Signer will generate a blind signature over an array of messages provided (and committed) by the Prover (<code>committed_messages</code>) and a pseudonym secret <code>prover_nym</code>, also chosen by the Prover. During signature generation, the Signer will provide their own randomness into the pseudonym secret. This will ensure that the pseudonym secret will always be unique, among different signature generation events.<a href="#section-6.1.1-1" class="pilcrow">¶</a></p>
<p id="section-6.1.1-2">This section will provide a high level description of the required operations, by detailing the modifications required in the relevant BBS blind signature operations, to also consider the use of pseudonyms. The full formal description of the operation can be seen at Appendix. We will reference those operations where appropriate in this section.<a href="#section-6.1.1-2" class="pilcrow">¶</a></p>
<p id="section-6.1.1-3">Initially, the Prover will chose a set of messages <code>committed_messages</code> that they want to be included in the signature, without reveling them to the Signer. They will also choose their part of the pseudonym secret <code>prover_nym</code> as a random scalar value.<a href="#section-6.1.1-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.1.1-4">
<pre>1. committed_messages.append(pid)
2. (commitment_with_proof, secret_prover_blind) = Commit(
                                                   committed_messages,
                                                   api_id)
3. convey commitment_with_proof to Signer.

</pre><a href="#section-6.1.1-4" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="blind-issuance">
<section id="section-6.1.2">
          <h4 id="name-blind-issuance">
<a href="#section-6.1.2" class="section-number selfRef">6.1.2. </a><a href="#name-blind-issuance" class="section-name selfRef">Blind Issuance</a>
          </h4>
<p id="section-6.1.2-1">The Signer generate a signature from a secret key (SK), the commitment with proof, and optionally over a <code>header</code> and vector of <code>messages</code> using
the BlindSign procedure from <span>[<a href="#I-D.kalos-bbs-blind-signatures" class="cite xref">I-D.kalos-bbs-blind-signatures</a>]</span>, substituting the call on the <code>B_calculate</code> of step 6, with the call to <code>B_calculate_with_nym</code> defined in Section <a href="#calculate-b" class="auto internal xref">Section 6.1.2.1</a>. More specifically, to issue a blind signature over a pseudonym, the Issuer will use BlindSign from <span>[<a href="#I-D.kalos-bbs-blind-signatures" class="cite xref">I-D.kalos-bbs-blind-signatures</a>]</span>, substituting steps 6, 7 and 8 with the following three steps<a href="#section-6.1.2-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.1.2-2">
<pre>6. res = B_calculate_with_nym(message_scalars, generators,
                                                   blind_generators[-1])
7. if res is INVALID, return INVALID
8. (B, signer_nym_entropy) = res

</pre><a href="#section-6.1.2-2" class="pilcrow">¶</a>
</div>
<p id="section-6.1.2-3">Lastly, the return statement of <code>BlindSign</code> should be updated to return the <code>signer_nym_entropy</code> value, returned by the call to the <code>B_calculate</code> operation.<a href="#section-6.1.2-3" class="pilcrow">¶</a></p>
<p id="section-6.1.2-4">The complete operation is defined in Appendix <a href="#detailed-blind-signature-generation-with-pseudonym" class="auto internal xref">Appendix B</a>.<a href="#section-6.1.2-4" class="pilcrow">¶</a></p>
<div id="calculate-b">
<section id="section-6.1.2.1">
            <h5 id="name-calculate-b">
<a href="#section-6.1.2.1" class="section-number selfRef">6.1.2.1. </a><a href="#name-calculate-b" class="section-name selfRef">Calculate B</a>
            </h5>
<p id="section-6.1.2.1-1">The <code>B_calculate_with_nym</code> operation is defined as follows,<a href="#section-6.1.2.1-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.1.2.1-2">
<pre>(B, signer_nym_entropy)  = B_calculate_with_nym(generators,
                                                nym_generator,
                                                commitment,
                                                message_scalars)

Inputs:

- generators (REQUIRED), an array of at least one point from the
                         G1 group.
- nym_generator (REQUIRED), a point from the G1 group
- commitment (REQUIRED), a point from the G1 group
- message_scalars (OPTIONAL), an array of scalar values. If not
                              supplied, it defaults to the empty
                              array ("()").

Deserialization:

1. L = length(messages)
2. if length(generators) != L + 1, return INVALID
3. (Q_1, H_1, ..., H_L) = generators

Procedure:

1. B = Q_1 + H_1 * msg_1 + ... + H_L * msg_L
2. signer_nym_entropy = get_random(1)
3. B = B + nym_generator * signer_nym_entropy
4. If B is Identity_G1, return INVALID
5. return (B, signer_nym_entropy)

</pre><a href="#section-6.1.2.1-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="verification-and-finalization">
<section id="section-6.1.3">
          <h4 id="name-verification-and-finalizati">
<a href="#section-6.1.3" class="section-number selfRef">6.1.3. </a><a href="#name-verification-and-finalizati" class="section-name selfRef">Verification and Finalization</a>
          </h4>
<p id="section-6.1.3-1">The following operation both verifies the generated blind signature, as well as calculating and returning the final <code>nym_secret</code>, used to calculate the Pseudonym value during proof generation.<a href="#section-6.1.3-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.1.3-2">
<pre>nym_secret = Finalize(PK,
                      signature,
                      header,
                      messages,
                      committed_messages,
                      prover_nym,
                      signer_nym_entropy)

Inputs:

- PK (REQUIRED), an octet string of the form outputted by the SkToPk
                 operation.
- signature (REQUIRED), an octet string of the form outputted by the
                        Sign operation.
- header (OPTIONAL), an octet string containing context and application
                     specific information. If not supplied, it defaults
                     to an empty string.
- messages (OPTIONAL), a vector of octet strings. If not supplied, it
                       defaults to the empty array "()".
- committed_messages (OPTIONAL), a vector of octet strings. If not
                                 supplied, it defaults to the empty
                                 array "()".
- prover_nym (OPTIONAL), scalar value. If not supplied, it defaults to
                         the zero scalar (0).
- signer_nym_entropy (OPTIONAL), a scalar value. If not supplied, it
                                 defaults to the zero scalar (0).

Procedure:

1. nym_secret = prover_nym + signer_nym_entropy
2. committed_messages.append(nym_secret)
3. res = Verify(PK, signature, header, messages, committed_messages)
4. if res is INVALID, return INVALID
5. return nym_secret

</pre><a href="#section-6.1.3-2" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="proof-generation-with-pseudonym">
<section id="section-6.2">
        <h3 id="name-proof-generation-with-pseud">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-proof-generation-with-pseud" class="section-name selfRef">Proof Generation with Pseudonym</a>
        </h3>
<p id="section-6.2-1">This section defines the <code>ProofGenWithPseudonym</code> operations, for calculating a BBS proof with a pseudonym. The BBS proof is extended to include a zero-knowledge proof of correctness of the pseudonym value, i.e., that is correctly calculated using the (undisclosed) pseudonym secret (<code>nym_secret</code>), and that is "bound" to the underlying BBS signature (i.e., that the <code>nym_secret</code> value is signed by the Signer).<a href="#section-6.2-1" class="pilcrow">¶</a></p>
<p id="section-6.2-2">Validating the proof (see <code>ProofVerifyWithPseudonym</code> defined in <a href="#proof-verification-with-pseudonym" class="auto internal xref">Section 6.3</a>), guarantees authenticity and integrity of the header, presentation header and disclosed messages, knowledge of a valid BBS signature as well as correctness and ownership of the pseudonym.<a href="#section-6.2-2" class="pilcrow">¶</a></p>
<p id="section-6.2-3">To support pseudonyms, the <code>ProofGen</code> procedure will be extended to accept the pseudonym secret <code>nym_secret</code>, as well as the context identifier <code>context_id</code>, which the pseudonym will be bounded to. The <code>nym_secret</code> scalar value should be added to the <code>committed_message_scalars</code> list computed in <code>ProofGen</code>. More specifically, step 4 of the <code>ProofGen</code> Procedure, defined in Section TBD will be substituted with the following step<a href="#section-6.2-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.2-4">
<pre>4.  committed_message_scalars
            .append(BBS.messages_to_scalars(committed_messages, api_id))
            .append(nym_secret)

</pre><a href="#section-6.2-4" class="pilcrow">¶</a>
</div>
<p id="section-6.2-5">This operation makes use of <code>CoreProofGenWithPseudonym</code> as defined in <a href="#core-proof-generation" class="auto internal xref">Section 7.1</a>.<a href="#section-6.2-5" class="pilcrow">¶</a></p>
<p id="section-6.2-6">Further more, the call to the <code>BBS.CoreProofGen</code> operation at step 10 of the <code>BlindProofGen</code> Procedure will be substituted with a call to <code>CoreProofGenWithNym</code> operation, defined in Section <a href="#core-proof-generation" class="auto internal xref">Section 7.1</a>. More specifically, step 11 of <code>BlindProofGen</code> will be substituted by the following step.<a href="#section-6.2-6" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.2-7">
<pre>11. proof = CoreProofGenWithNym(PK,
                                signature,
                                generators.append(blind_generators),
                                header,
                                ph,
                                context_id,
                                message_scalars.append(committed_message_scalars),
                                indexes,
                                api_id)

</pre><a href="#section-6.2-7" class="pilcrow">¶</a>
</div>
<p id="section-6.2-8">The <code>ProofGenWithPseudonym</code> operation is described in detail in Appendix <a href="#detailed-proof-generation-with-pseudonym" class="auto internal xref">Appendix C</a><a href="#section-6.2-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="proof-verification-with-pseudonym">
<section id="section-6.3">
        <h3 id="name-proof-verification-with-pse">
<a href="#section-6.3" class="section-number selfRef">6.3. </a><a href="#name-proof-verification-with-pse" class="section-name selfRef">Proof Verification with Pseudonym</a>
        </h3>
<p id="section-6.3-1">This operation validates a BBS proof with a pseudonym, given the Signer's public key (PK), the proof, the pseudonym, the context identifier that was used to create it, a header and presentation header, the disclosed messages and committed messages as well as the, the indexes those messages had in the original vectors of signed messages. Validating the proof also validates the correctness and ownership by the Prover of the received pseudonym.<a href="#section-6.3-1" class="pilcrow">¶</a></p>
<p id="section-6.3-2">To support pseudonyms, the <code>BlindProofVerify</code> procedure will be extended to accept the pseudonym value <code>Pseudonym</code>, as well as the context identifier <code>context_id</code>, which the pseudonym is bounded to. Additionally, the call to the <code>BBS.CoreProofVerify</code> operation at step 9, will be replaced with a call to the core proof verification operation with pseudonyms defined in this document, i.e., of <code>CoreProofVerifyWithPseudonym</code> as defined in <a href="#core-proof-verification" class="auto internal xref">Section 7.2</a>.<a href="#section-6.3-2" class="pilcrow">¶</a></p>
<p id="section-6.3-3">More specifically, step 9 of the <code>BlindProofVerify</code> Procedure will be replaced with the following step,<a href="#section-6.3-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-6.3-4">
<pre>9.  result = CoreProofVerifyWithPseudonym(
                                    PK,
                                    proof,
                                    Pseudonym,
                                    context_id,
                                    generators.append(blind_generators),
                                    header,
                                    ph,
                                    message_scalars,
                                    indexes,
                                    api_id)

</pre><a href="#section-6.3-4" class="pilcrow">¶</a>
</div>
<p id="section-6.3-5">The <code>ProofVerifyWithPseudonym</code> operation is described in detail in Appendix <a href="#detailed-proof-verification-with-pseudonym" class="auto internal xref">Appendix D</a>.<a href="#section-6.3-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="core-operations">
<section id="section-7">
      <h2 id="name-core-operations">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-core-operations" class="section-name selfRef">Core Operations</a>
      </h2>
<div id="core-proof-generation">
<section id="section-7.1">
        <h3 id="name-core-proof-generation">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-core-proof-generation" class="section-name selfRef">Core Proof Generation</a>
        </h3>
<p id="section-7.1-1">This operations computes a BBS proof and a zero-knowledge proof of correctness of the pseudonym in "parallel" (meaning using common randomness), as to both create a proof that the pseudonym was correctly calculated using an undisclosed value that the Prover knows (i.e., the <code>pid</code> value), but also that this value is "signed" by the BBS signature (the last undisclosed message). As a result, validating the proof guarantees that the pseudonym is correctly computed and that it was computed using the Prover identifier that was included in the BBS signature.<a href="#section-7.1-1" class="pilcrow">¶</a></p>
<p id="section-7.1-2">The operation uses the <code>ProofInit</code> and <code>ProofFinalize</code> operations defined in <span>[<a href="#I-D.irtf-cfrg-bbs-signatures" class="cite xref">I-D.irtf-cfrg-bbs-signatures</a>]</span>, the <code>PseudonymProofInit</code> operation defined in <a href="#pseudonym-proof-generation-initialization" class="auto internal xref">Section 7.3.1</a> and the <code>ProofWithPseudonymChallengeCalculate</code> defined in <a href="#challenge-calculation" class="auto internal xref">Section 8.1</a>.<a href="#section-7.1-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.1-3">
<pre>proof = CoreProofGenWithPseudonym(PK,
                                  signature,
                                  Pseudonym,
                                  verifier_id,
                                  generators,
                                  header,
                                  ph,
                                  messages,
                                  disclosed_indexes,
                                  api_id)

Inputs:

- PK (REQUIRED), an octet string of the form outputted by the SkToPk
                 operation.
- signature (REQUIRED), an octet string of the form outputted by the
                        Sign operation.
- Pseudonym (REQUIRED), A point of G1, different from the Identity of
                        G1, as outputted by the CalculatePseudonym
                        operation.
- context_id (REQUIRED), an octet string, representing the unique proof
                          Verifier identifier.
- generators (REQUIRED), vector of points in G1.
- header (OPTIONAL), an octet string containing context and application
                     specific information. If not supplied, it defaults
                     to an empty string.
- ph (OPTIONAL), an octet string containing the presentation header. If
                 not supplied, it defaults to an empty string.
- message_scalars (OPTIONAL), a vector of scalars representing the
                              messages. If not supplied, it defaults to
                              the empty array "()" must include the pid
                              scalar as last element.
- disclosed_indexes (OPTIONAL), vector of unsigned integers in ascending
                                order. Indexes of disclosed messages. If
                                not supplied, it defaults to the empty
                                array "()".
- api_id (OPTIONAL), an octet string. If not supplied it defaults to the
                     empty octet string ("").

Parameters:

- P1, fixed point of G1, defined by the ciphersuite.

Outputs:

- proof, an octet string; or INVALID.

Deserialization:

1.  signature_result = octets_to_signature(signature)
2.  if signature_result is INVALID, return INVALID
3.  (A, e) = signature_result
4.  L = length(message_scalars)
5.  R = length(disclosed_indexes)
6.  (i1, ..., iR) = disclosed_indexes
7.  if R &gt; L - 1, return INVALID, Note: we never reveal the pid value.
8.  U = L - R

// Note: pid is last message and is not revealed.
9.  undisclosed_indexes = (0, 1, ..., L - 1) \ disclosed_indexes
10. (i1, ..., iR) = disclosed_indexes
11. (j1, ..., jU) = undisclosed_indexes
12. disclosed_messages = (message_scalars[i1], ..., message_scalars[iR])
13. undisclosed_messages = (message_scalars[j1], ...,
                                                    message_scalars[jU])

ABORT if:

1. for i in disclosed_indexes, i &lt; 0 or i &gt; L - 1, // Note: pid  is L
                                                   // message and not
                                                   // revealed.

Procedure:

1. random_scalars = calculate_random_scalars(5+U)
2. init_res = ProofInit(PK,
                        signature_res,
                        header,
                        random_scalars,
                        generators,
                        message_scalars,
                        undisclosed_indexes,
                        api_id)
3. if init_res is INVALID, return INVALID

4. pseudonym_init_res = PseudonymProofInit(context_id,
                                           message_scalars[-1],
                                           random_scalars[-1])
5. if pseudonym_init_res is INVALID, return INVALID
6. Pseudonym = pseudonym_init_res[0]

7. challenge = ProofWithPseudonymChallengeCalculate(init_res,
                                                    pseudonym_init_res,
                                                    disclosed_indexes,
                                                    disclosed_messages,
                                                    ph,
                                                    api_id)
8. proof = ProofFinalize(init_res, challenge, e_value, random_scalars,
                                                   undisclosed_messages)
9. return (proof, Pseudonym)

</pre><a href="#section-7.1-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="core-proof-verification">
<section id="section-7.2">
        <h3 id="name-core-proof-verification">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-core-proof-verification" class="section-name selfRef">Core Proof Verification</a>
        </h3>
<p id="section-7.2-1">This operation validates a BBS proof that also includes a pseudonym. Validating the proof, other than the correctness and integrity of the revealed messages, the header and the presentation header values, also guarantees that the supplied pseudonym was correctly calculated, i.e., that it was produced using the Verifier's identifier and the signed (but undisclosed) Prover's identifier, following the operation defined in <a href="#pseudonym-calculation-procedure" class="auto internal xref">Section 4</a>.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2-2">The operation uses the <code>ProofVerifyInit</code> operation defined in <span>[<a href="#I-D.irtf-cfrg-bbs-signatures" class="cite xref">I-D.irtf-cfrg-bbs-signatures</a>]</span>, the <code>PseudonymProofVerifyInit</code> operation defined in <a href="#pseudonym-proof-verification-initialization" class="auto internal xref">Section 7.3.2</a> and the <code>ProofWithPseudonymChallengeCalculate</code> operation defined in <a href="#challenge-calculation" class="auto internal xref">Section 8.1</a>.<a href="#section-7.2-2" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-7.2-3">
<pre>result = CoreProofVerifyWithPseudonym(PK,
                                      proof,
                                      Pseudonym,
                                      context_id,
                                      generators,
                                      header,
                                      ph,
                                      disclosed_messages,
                                      disclosed_indexes,
                                      api_id)

Inputs:

- PK (REQUIRED), an octet string of the form outputted by the SkToPk
                 operation.
- proof (REQUIRED), an octet string of the form outputted by the
                    ProofGen operation.
- Pseudonym (REQUIRED), A point of G1, different from the Identity of
                        G1, as outputted by the CalculatePseudonym
                        operation.
- context_id (REQUIRED), an octet string, representing the unique proof
                         Verifier identifier.
- generators (REQUIRED), vector of points in G1.
- header (OPTIONAL), an optional octet string containing context and
                     application specific information. If not supplied,
                     it defaults to an empty string.
- ph (OPTIONAL), an octet string containing the presentation header. If
                 not supplied, it defaults to an empty string.
- disclosed_messages (OPTIONAL), a vector of scalars representing the
                                 messages. If not supplied, it defaults
                                 to the empty array "()".
- disclosed_indexes (OPTIONAL), vector of unsigned integers in ascending
                                order. Indexes of disclosed messages. If
                                not supplied, it defaults to the empty
                                array "()".
- api_id (OPTIONAL), an octet string. If not supplied it defaults to the
                     empty octet string ("").

Parameters:

- P1, fixed point of G1, defined by the ciphersuite.

Outputs:

- result, either VALID or INVALID.

Deserialization:

1. proof_result = octets_to_proof(proof)
2. if proof_result is INVALID, return INVALID
3. (Abar, Bbar, r2^, r3^, commitments, cp) = proof_result
4. W = octets_to_pubkey(PK)
5. if W is INVALID, return INVALID
6. R = length(disclosed_indexes)
7. (i1, ..., iR) = disclosed_indexes

ABORT if:

1. for i in disclosed_indexes, i &lt; 1 or i &gt; R + length(commitments) - 1

Procedure:

1. init_res = ProofVerifyInit(PK, proof_result, header, generators,
                                    messages, disclosed_indexes, api_id)

2. pseudonym_init_res = PseudonymProofVerifyInit(Pseudonym,
                                                 context_id,
                                                 commitments[-1],
                                                 cp)
3. if pseudonym_init_res is INVALID, return INVALID

4. challenge = ProofWithPseudonymChallengeCalculate(init_res,
                                                    pseudonym_init_res,
                                                    disclosed_indexes,
                                                    messages,
                                                    ph,
                                                    api_id)
5. if cp != challenge, return INVALID
6. if e(Abar, W) * e(Bbar, -BP2) != Identity_GT, return INVALID
7. return VALID

</pre><a href="#section-7.2-3" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="pseudonym-proof-generation-utilities">
<section id="section-7.3">
        <h3 id="name-pseudonym-proof-generation-">
<a href="#section-7.3" class="section-number selfRef">7.3. </a><a href="#name-pseudonym-proof-generation-" class="section-name selfRef">Pseudonym Proof Generation Utilities</a>
        </h3>
<div id="pseudonym-proof-generation-initialization">
<section id="section-7.3.1">
          <h4 id="name-pseudonym-proof-generation-i">
<a href="#section-7.3.1" class="section-number selfRef">7.3.1. </a><a href="#name-pseudonym-proof-generation-i" class="section-name selfRef">Pseudonym Proof Generation Initialization</a>
          </h4>
<div class="alignLeft art-text artwork" id="section-7.3.1-1">
<pre>pseudonym_init_res = PseudonymProofInit(context_id,
                                          nym_secret, random_scalar)

Inputs:

- context_id (REQUIRED), an octet string
- nym_secret (REQUIRED), a scalar value
- random_scalar (REQUIRED), a scalar value

Outputs:

- a tuple consisting of three elements from the G1 group, or INVALID.

Procedure:

1. OP = hash_to_curve_g1(context_id, api_id)
2. Pseudonym = OP * nym_secret
3. Ut = OP * random_scalar
4. if Pseudonym == Identity_G1 or Ut == Identity_G1, return INVALID
5. return (Pseudonym, OP, Ut)

</pre><a href="#section-7.3.1-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="pseudonym-proof-verification-initialization">
<section id="section-7.3.2">
          <h4 id="name-pseudonym-proof-verificatio">
<a href="#section-7.3.2" class="section-number selfRef">7.3.2. </a><a href="#name-pseudonym-proof-verificatio" class="section-name selfRef">Pseudonym Proof Verification Initialization</a>
          </h4>
<div class="alignLeft art-text artwork" id="section-7.3.2-1">
<pre>pseudonym_init_res = PseudonymProofVerifyInit(Pseudonym,
                                              context_id,
                                              nym_secret_commitment
                                              proof_challenge)

Inputs:

- Pseudonym (REQUIRED), an element of the G1 group.
- context_id (REQUIRED), an octet string.
- nym_secret_commitment (REQUIRED), a scalar value.
- proof_challenge (REQUIRED), a scalar value.

Outputs:

- a tuple consisting of three elements from the G1 group, or INVALID.

Procedure:

1. OP = hash_to_curve_g1(context_id)
2. Uv = OP * nym_secret_commitment - Pseudonym * proof_challenge
3. if Uv == Identity_G1, return INVALID
4. return (Pseudonym, OP, Uv)

</pre><a href="#section-7.3.2-1" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="utility-operations">
<section id="section-8">
      <h2 id="name-utility-operations">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-utility-operations" class="section-name selfRef">Utility Operations</a>
      </h2>
<div id="challenge-calculation">
<section id="section-8.1">
        <h3 id="name-challenge-calculation">
<a href="#section-8.1" class="section-number selfRef">8.1. </a><a href="#name-challenge-calculation" class="section-name selfRef">Challenge Calculation</a>
        </h3>
<div class="alignLeft art-text artwork" id="section-8.1-1">
<pre>challenge = ProofWithPseudonymChallengeCalculate(init_res,
                                                 pseudonym_init_res,
                                                 i_array,
                                                 msg_array,
                                                 ph, api_id)

Inputs:
- init_res (REQUIRED), vector representing the value returned after
                       initializing the proof generation or verification
                       operations, consisting of 5 points of G1 and a
                       scalar value, in that order.
- pseudonym_init_res (REQUIRED), vector representing the value returned
                                 after initializing the pseudonym proof,
                                 consisting of 3 points of G1.
- i_array (REQUIRED), array of non-negative integers (the indexes of
                      the disclosed messages).
- msg_array (REQUIRED), array of scalars (the disclosed messages after
                        mapped to scalars).
- ph (OPTIONAL), an octet string. If not supplied, it must default to
                 the empty octet string ("").
- api_id (OPTIONAL), an octet string. If not supplied it defaults to the
                     empty octet string ("").

Outputs:

- challenge, a scalar.

Definitions:

1. challenge_dst, an octet string representing the domain separation
                  tag: api_id || "H2S_" where "H2S_" is an ASCII string
                  comprised of 4 bytes.

Deserialization:

1. R = length(i_array)
2. (i1, ..., iR) = i_array
3. (msg_i1, ..., msg_iR) = msg_array
4. (Abar, Bbar, D, T1, T2, domain) = init_res
5. (Pseudonym, OP, Ut) = pseudonym_init_res

ABORT if:

1. R &gt; 2^64 - 1 or R != length(msg_array)
2. length(ph) &gt; 2^64 - 1

Procedure:
1. c_arr = (R, i1, msg_i1, i2, msg_i2, ..., iR, msg_iR, Abar, Bbar,
                                   D, T1, T2, Pseudonym, OP, Ut, domain)
2. c_octs = serialize(c_arr) || I2OSP(length(ph), 8) || ph
3. return hash_to_scalar(c_octs, challenge_dst)

</pre><a href="#section-8.1-1" class="pilcrow">¶</a>
</div>
</section>
</div>
</section>
</div>
<div id="security-considerations">
<section id="section-9">
      <h2 id="name-security-considerations">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-9-1">TODO Security<a href="#section-9-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ciphersuites">
<section id="section-10">
      <h2 id="name-ciphersuites">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-ciphersuites" class="section-name selfRef">Ciphersuites</a>
      </h2>
<p id="section-10-1">This document does not define new BBS ciphersuites. Its ciphersuite defined in <a href="https://www.ietf.org/archive/id/draft-irtf-cfrg-bbs-signatures-03.html#name-ciphersuites">Section 6</a> of <span>[<a href="#I-D.irtf-cfrg-bbs-signatures" class="cite xref">I-D.irtf-cfrg-bbs-signatures</a>]</span>) can be used to instantiate the operations of the described scheme.<a href="#section-10-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="iana-considerations">
<section id="section-11">
      <h2 id="name-iana-considerations">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-11-1">This document has no IANA actions.<a href="#section-11-1" class="pilcrow">¶</a></p>
</section>
</div>
<section id="section-12">
      <h2 id="name-references">
<a href="#section-12" class="section-number selfRef">12. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-12.1">
        <h3 id="name-normative-references">
<a href="#section-12.1" class="section-number selfRef">12.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="I-D.irtf-cfrg-bbs-signatures">[I-D.irtf-cfrg-bbs-signatures]</dt>
        <dd>
<span class="refAuthor">Looker, T.</span>, <span class="refAuthor">Kalos, V.</span>, <span class="refAuthor">Whitehead, A.</span>, and <span class="refAuthor">M. Lodder</span>, <span class="refTitle">"The BBS Signature Scheme"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-irtf-cfrg-bbs-signatures-07</span>, <time datetime="2024-09-23" class="refDate">23 September 2024</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bbs-signatures-07">https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bbs-signatures-07</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.irtf-cfrg-hash-to-curve">[I-D.irtf-cfrg-hash-to-curve]</dt>
        <dd>
<span class="refAuthor">Faz-Hernandez, A.</span>, <span class="refAuthor">Scott, S.</span>, <span class="refAuthor">Sullivan, N.</span>, <span class="refAuthor">Wahby, R. S.</span>, and <span class="refAuthor">C. A. Wood</span>, <span class="refTitle">"Hashing to Elliptic Curves"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-irtf-cfrg-hash-to-curve-16</span>, <time datetime="2022-06-15" class="refDate">15 June 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16">https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.irtf-cfrg-pairing-friendly-curves">[I-D.irtf-cfrg-pairing-friendly-curves]</dt>
        <dd>
<span class="refAuthor">Sakemi, Y.</span>, <span class="refAuthor">Kobayashi, T.</span>, <span class="refAuthor">Saito, T.</span>, and <span class="refAuthor">R. S. Wahby</span>, <span class="refTitle">"Pairing-Friendly Curves"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-irtf-cfrg-pairing-friendly-curves-11</span>, <time datetime="2022-11-06" class="refDate">6 November 2022</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11">https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="I-D.kalos-bbs-blind-signatures">[I-D.kalos-bbs-blind-signatures]</dt>
        <dd>
<span class="refAuthor">Kalos, V.</span> and <span class="refAuthor">G. M. Bernstein</span>, <span class="refTitle">"Blind BBS Signatures"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-kalos-bbs-blind-signatures-01</span>, <time datetime="2024-07-08" class="refDate">8 July 2024</time>, <span>&lt;<a href="https://datatracker.ietf.org/doc/html/draft-kalos-bbs-blind-signatures-01">https://datatracker.ietf.org/doc/html/draft-kalos-bbs-blind-signatures-01</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
      <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-12.2">
        <h3 id="name-informative-references">
<a href="#section-12.2" class="section-number selfRef">12.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="BBS04">[BBS04]</dt>
      <dd>
<span class="refAuthor">Boneh, D.</span>, <span class="refAuthor">Boyen, X.</span>, and <span class="refAuthor">H. Shacham</span>, <span class="refTitle">"Short Group Signatures"</span>, <span class="seriesInfo">In Advances in Cryptology</span>, <span class="seriesInfo">pages 41-55</span>, <time datetime="2004" class="refDate">2004</time>, <span>&lt;<a href="https://link.springer.com/chapter/10.1007/978-3-540-28628-8_3">https://link.springer.com/chapter/10.1007/978-3-540-28628-8_3</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="acknowledgments">
<section id="appendix-A">
      <h2 id="name-acknowledgments">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="appendix-A-1">TODO acknowledge.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="detailed-blind-signature-generation-with-pseudonym">
<section id="appendix-B">
      <h2 id="name-detailed-blind-signature-ge">
<a href="#appendix-B" class="section-number selfRef">Appendix B. </a><a href="#name-detailed-blind-signature-ge" class="section-name selfRef">Detailed Blind Signature Generation with Pseudonym</a>
      </h2>
<div class="alignLeft art-text artwork" id="appendix-B-1">
<pre>BlindSignWithNym(SK, PK, commitment_with_proof, header, messages)

Inputs:

- SK (REQUIRED), a secret key in the form outputted by the KeyGen
                 operation.
- PK (REQUIRED), an octet string of the form outputted by SkToPk
                 provided the above SK as input.
- commitment_with_proof (OPTIONAL), an octet string, representing a
                                    serialized commitment and
                                    commitment_proof, as the first
                                    element outputted by the Commit
                                    operation. If not supplied, it
                                    defaults to the empty string ("").
- header (OPTIONAL), an octet string containing context and application
                     specific information. If not supplied, it defaults
                     to an empty string ("").
- messages (OPTIONAL), a vector of octet strings. If not supplied, it
                       defaults to the empty array ("()").

Deserialization:

1. L = length(messages)

// calculate the number of blind generators used by the commitment,
// if any.
2. M = length(commitment_with_proof)
3. if M != 0, M = M - octet_point_length - octet_scalar_length
4. M = M / octet_scalar_length
5. if M &lt; 0, return INVALID

Procedure:

1.  generators = BBS.create_generators(L + 1, api_id)
2.  blind_generators = BBS.create_generators(M, "BLIND_" || api_id)

3.  commit = deserialize_and_validate_commit(commitment_with_proof,
                                               blind_generators, api_id)
4.  if commit is INVALID, return INVALID

5.  message_scalars = BBS.messages_to_scalars(messages, api_id)

6.  res = B_calculate(message_scalars, generators, blind_generators[-1])
7.  if res is INVALID, return INVALID
8.  (B, signer_nym_entropy) = res

9.  blind_sig = FinalizeBlindSign(SK,
                                  PK,
                                  B,
                                  generators,
                                  blind_generators,
                                  header,
                                  api_id)

10. if blind_sig is INVALID, return INVALID
11. return (blind_sig, signer_nym_entropy)

</pre><a href="#appendix-B-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="detailed-proof-generation-with-pseudonym">
<section id="appendix-C">
      <h2 id="name-detailed-proof-generation-w">
<a href="#appendix-C" class="section-number selfRef">Appendix C. </a><a href="#name-detailed-proof-generation-w" class="section-name selfRef">Detailed Proof Generation with Pseudonym</a>
      </h2>
<div class="alignLeft art-text artwork" id="appendix-C-1">
<pre>proof = ProofGenWithNym(PK,
                        signature,
                        header,
                        ph,
                        nym_secret,
                        context_id,
                        messages,
                        committed_messages,
                        disclosed_indexes,
                        disclosed_commitment_indexes,
                        secret_prover_blind)

Inputs:

- PK (REQUIRED), an octet string of the form outputted by the SkToPk
                 operation.
- signature (REQUIRED), an octet string of the form outputted by the
                        Sign operation.
- header (OPTIONAL), an octet string containing context and application
                     specific information. If not supplied, it defaults
                     to an empty string.
- ph (OPTIONAL), an octet string containing the presentation header. If
                 not supplied, it defaults to an empty string.
- messages (OPTIONAL), a vector of octet strings. If not supplied, it
                       defaults to the empty array "()".
- committed_messages (OPTIONAL), a vector of octet strings. If not
                                 supplied, it defaults to the empty
                                 array "()".
- disclosed_indexes (OPTIONAL), vector of unsigned integers in ascending
                                order. Indexes of disclosed messages. If
                                not supplied, it defaults to the empty
                                array "()".
- disclosed_commitment_indexes (OPTIONAL), vector of unsigned integers
                                           in ascending order. Indexes
                                           of disclosed committed
                                           messages. If not supplied, it
                                           defaults to the empty array
                                           "()".
- secret_prover_blind (OPTIONAL), a scalar value. If not supplied it
                                  defaults to zero "0".


Parameters:

- api_id, the octet string ciphersuite_id || "BLIND_H2G_HM2S_", where
          ciphersuite_id is defined by the ciphersuite and
          "BLIND_H2G_HM2S_"is an ASCII string composed of 15 bytes.


Outputs:

- proof, an octet string; or INVALID.

Deserialization:

1. L = length(messages)
2. M = length(committed_messages)
3. if length(disclosed_indexes) &gt; L, return INVALID
4. for i in disclosed_indexes, if i &lt; 0 or i &gt;= L, return INVALID
5. if length(disclosed_commitment_indexes) &gt; M, return INVALID
6. for j in disclosed_commitment_indexes,
                               if i &lt; 0 or i &gt;= M, return INVALID

Procedure:

1.  message_scalars = BBS.messages_to_scalars(messages, api_id)

2.  committed_message_scalars = ()
3.  committed_message_scalars.append(secret_prover_blind)
4.  committed_message_scalars.append(BBS.messages_to_scalars(
                                            committed_messages, api_id))
5.  committed_message_scalars.append(nym_secret)


6.  generators = BBS.create_generators(length(message_scalars) + 1, api_id)
7.  blind_generators = BBS.create_generators(length(committed_message_scalars) + 1, "BLIND_" || api_id)

8.  indexes = ()
9.  indexes.append(disclosed_indexes)
10. for j in disclosed_commitment_indexes: indexes.append(j + L + 1)

11. proof = CoreProofGenWithNym(PK,
                                signature,
                                generators.append(blind_generators),
                                header,
                                ph,
                                context_id,
                                message_scalars.append(committed_message_scalars),
                                indexes,
                                api_id)
12. return proof

</pre><a href="#appendix-C-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="detailed-proof-verification-with-pseudonym">
<section id="appendix-D">
      <h2 id="name-detailed-proof-verification">
<a href="#appendix-D" class="section-number selfRef">Appendix D. </a><a href="#name-detailed-proof-verification" class="section-name selfRef">Detailed Proof Verification with Pseudonym</a>
      </h2>
<div class="alignLeft art-text artwork" id="appendix-D-1">
<pre>result = ProofVerifyWithPseudonym(PK,
                                  proof,
                                  header,
                                  ph,
                                  Pseudonym,
                                  context_id,
                                  L,
                                  disclosed_messages,
                                  disclosed_committed_messages,
                                  disclosed_indexes,
                                  disclosed_committed_indexes)

Inputs:

- PK (REQUIRED), an octet string of the form outputted by the SkToPk
                 operation.
- proof (REQUIRED), an octet string of the form outputted by the
                    ProofGen operation.
- header (OPTIONAL), an optional octet string containing context and
                     application specific information. If not supplied,
                     it defaults to the empty octet string ("").
- ph (OPTIONAL), an octet string containing the presentation header. If
                 not supplied, it defaults to the empty octet
                 string ("").
- L (OPTIONAL), an integer, representing the total number of Signer
                known messages if not supplied it defaults to 0.
- disclosed_messages (OPTIONAL), a vector of octet strings. If not
                                 supplied, it defaults to the empty
                                 array ("()").
- disclosed_indexes (OPTIONAL), vector of unsigned integers in ascending
                                order. Indexes of disclosed messages. If
                                not supplied, it defaults to the empty
                                array ("()").

Parameters:

- api_id, the octet string ciphersuite_id || "H2G_HM2S_", where
          ciphersuite_id is defined by the ciphersuite and "H2G_HM2S_"is
          an ASCII string comprised of 9 bytes.
- (octet_point_length, octet_scalar_length), defined by the ciphersuite.

Outputs:

- result, either VALID or INVALID.

Deserialization:

1. proof_len_floor = 2 * octet_point_length + 3 * octet_scalar_length
2. if length(proof) &lt; proof_len_floor, return INVALID
3. U = floor((length(proof) - proof_len_floor) / octet_scalar_length)
4. total_no_messages = length(disclosed_indexes) +
                                 length(disclosed_committed_indexes) + U
5. M = total_no_messages - L

Procedure:

1.  generators = BBS.create_generators(L + 1, api_id)
2.  blind_generators = BBS.create_generators(M + 1, "BLIND_" || api_id)

3.  disclosed_message_scalars = messages_to_scalars(
                                             disclosed_messages, api_id)
4.  disclosed_committed_message_scalars = messages_to_scalars(
                                   disclosed_committed_messages, api_id)
5.  message_scalars = disclosed_message_scalars.append(
                                    disclosed_committed_message_scalars)

6.  indexes = ()
7.  indexes.append(disclosed_indexes)
8.  for j in disclosed_commitment_indexes: indexes.append(j + L + 1)

9.  result = CoreProofVerifyWithPseudonym(
                                    PK,
                                    proof,
                                    Pseudonym,
                                    context_id,
                                    generators.append(blind_generators),
                                    header,
                                    ph,
                                    message_scalars,
                                    indexes,
                                    api_id)
10. return result

</pre><a href="#appendix-D-1" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-E">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Vasilis Kalos</span></div>
<div dir="auto" class="left"><span class="org">MATTR</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:vasilis.kalos@mattr.global" class="email">vasilis.kalos@mattr.global</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Greg Bernstein</span></div>
<div dir="auto" class="left"><span class="org">Grotto Networking</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:gregb@grotto-networking.com" class="email">gregb@grotto-networking.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
